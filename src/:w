#include "../include/snake.h"

Node *create_node(unsigned int x, unsigned int y) {
  Node *node = malloc(sizeof(Node));
  node->x = x;
  node->y = y;
  node->next = NULL;
  return node;
}
void insert_at_head(Node **head, Node *node) {
  node->next = *head;
  *head = node;
}

void delete_list(Node *head) {
  Node *ptr = head;
  while (ptr) {
    Node *next = ptr->next;
    free(ptr);
    ptr = next;
  }
}
void remove_node(Node **head, Node *node_to_remove) {
  if (*head == node_to_remove) {
    *head = node_to_remove->next;
    free(head);
    return;
  }
  Node *ptr = *head;

  while (ptr && ptr->next != node_to_remove) {
    ptr = ptr->next;
  }
  if (ptr == NULL)
    return;
  ptr->next = node_to_remove->next;
  free(node_to_remove);
}

void insert_after(Node *node_to_insert_after, Node *new_node) {
  if (node_to_insert_after) {
    new_node->next = node_to_insert_after->next;
    node_to_insert_after->next = new_node;
  } else
    return;
}
Node *init_snake(DefaultValues _default) {
  Node *snake_head =
      create_node(_default.defaultSnakeX, _default.defaultSnakeY);
  Node *snake_body =
      create_node(_default.defaultSnakeX + 1, _default.defaultSnakeY);

  insert_at_head(&snake_body, snake_head);
  insert_after(snake_body,
               create_node(_default.defaultSnakeX + 2, _default.defaultSnakeX));
  snake_body = snake_head;
  Node *ptr = snake_body;
  while (ptr) {
    mvaddch(ptr->y, ptr->x, ACS_BLOCK);
    ptr = ptr->next;
  }
  refresh();
  return snake_head;
}
enum Directions get_direction(enum Directions *dir, enum Directions prev_dir) {
  int ch = getch();
  switch (ch) {
  case KEY_LEFT:
    if (prev_dir != RIGHT)
      *dir = LEFT;
    break;

  case KEY_RIGHT:
    if (prev_dir != LEFT)
      *dir = RIGHT;
    break;

  case KEY_UP:
    if (prev_dir != DOWN)
      *dir = UP;
    break;

  case KEY_DOWN:
    if (prev_dir != UP)
      *dir = DOWN;
    break;
  case 'q':
    *dir = -1;
    break;
  }
  return *dir;
}
void move_snake(enum Directions dir, Node *snake_head) {
  int opX = 1, opY = 1;

  switch (dir) {
  case LEFT:
    opX = -1;
    break;
  case RIGHT:
    opX = 1;
    break;
  case UP:
    opY = -1;
    break;
  case DOWN:
    opY = 1;
    break;
  }
  unsigned int newHeadX = snake_head->x + (opX),
               newHeadY = snake_head->y + (opY);
  Node *new_head = create_node(newHeadX, newHeadY);
  Node *ptr = snake_head;
  insert_at_head(&snake_head, new_head);
  while (snake_head->next) {
    if (dir == LEFT || dir == RIGHT)
      snake_head += opX;
    else if (dir == UP || dir == DOWN)
      snake_head += opY;
    snake_head = snake_head->next;
  }
  Node *last_el = snake_head;
  free(last_el);
  snake_head = ptr;
}

void display(Node *snake) {
  Node *ptr = snake;
  while (snake) {
    mvaddch(snake->y, snake->x, ACS_BLOCK);
    snake = snake->next;
  }
  snake = ptr;
}

bool is_beyond_border(Node *snake_head, Field field) {
  return (snake_head->x < 0 || snake_head->y < 0 ||
          snake_head->x > field.x_max || snake_head->y > field.y_max);
}
